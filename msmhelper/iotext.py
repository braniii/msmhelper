"""
Input and output text files.

BSD 3-Clause License
Copyright (c) 2019, Daniel Nagel
All rights reserved.

Author: Daniel Nagel

TODO:
    - create todo

"""
# ~~~ IMPORT ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import os
import sys
import datetime
import __main__ as main
import getpass  # get username with getpass.getuser()
import platform  # get pc name with platform.node()
import numpy as np
import pandas as pd


# ~~~ RUNTIME INFORMATION ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
USERNAME = getpass.getuser()
PLATFORM = platform.node()
EXEC_DATE = datetime.datetime.now()
try:
    SCRIPT_DIR, SCRIPT_NAME = os.path.split(main.__file__)
except:
    SCRIPT_DIR, SCRIPT_NAME = None, 'console'
else:
    pass


# ~~~ FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def opentxt(file_name, comment='#', usecols=None, nrows=None, skiprows=None,
            dtype=None):
    """
    Open a text file.

    This method can load an nxm array of floats from an ascii file. It uses
    either pandas read_csv or as fallback the slower numpy laodtxt.

    Parameters
    ----------
    file_name : string
        Name of file to be opened.

    comment : str, optional
        Characters with which a comment starts.

    usecols : int-array, optional
        Columns to be read from the file (zero indexed).

    nrows : int, optional
        The maximum number of lines to be read

    skiprows : int, optional
        The number of leading rows which will be skipped.

    dtype : data-type, optional
        Data-type of the resulting array. Default: float.

    Returns
    -------
    data : ndarray
        Data read from the text file.

    """
    if 'pandas' in sys.modules and len(comment) < 2:
        data = pd.read_csv(file_name,
                           sep=r'\s+',
                           header=None,
                           comment=comment,
                           usecols=usecols,
                           skiprows=skiprows,
                           nrows=nrows,
                           dtype=dtype).values
        if data.shape[-1] == 1:
            return data.flatten()
        else:
            return data
    elif 'numpy' in sys.modules:
        return np.loadtxt(file_name,
                          comments=comment,
                          usecols=usecols,
                          skiprows=skiprows,
                          max_rows=nrows,
                          dtype=dtype)
    else:
        assert True, "Neither numpy nor pandas were found"


def savetxt(file_name, data, header=None, fmt='%.5f'):
    """
    Save nxm array of floats to a text file.

    It uses numpys savetxt method and extends the header with information
    of execution.

    Parameters
    ----------
    file_name : string
        File name to store data.

    data : ndarray
        Data to be stored.

    header : str, optional
        Comment written into the header of the output file.

    fmt : str or sequence of strs, optional
        See numpy.savetxt fmt.

    """
    # prepare header comments
    header_comment = \
        'This file was generated by {} with :\n'.format(SCRIPT_NAME)
    for arg in sys.argv:  # loop over the given arguments
        header_comment += '{} '.format(arg)
    header_comment += '\n\n{}, {}@{}'.format(EXEC_DATE, USERNAME, PLATFORM)
    if header:  # print column title if given
        header_comment += '\n' + header

    # save file
    if 'numpy' in sys.modules:
        np.savetxt(file_name, data, fmt=fmt, header=header_comment)
    else:  # this case should never happen because numpy is required
        print('numpy was not found and pure python pendent is not ' +
              'yet implemented')


def opentxt_limits(*args, limits_file=None, **kwargs):
    """
    Load file and split according to limit file.

    Both, the limit file and the trajectory file needs to be a single column
    file. If limits_file is not provided it will return [traj]. The trajectory
    will of dtype np.int16, so the states needs to be smaller than 32767.

    Parameters
    ----------
    limits_file : str, optional
        File name of limit file. Should be single column ascii file.

    *args and **kwargs
        The Parameters defines in opentxt.

    Returns
    -------
    traj : ndarray
        Return array of subtrajectories.

    """
    # open trajectory
    if 'dtype' in kwargs:
        assert np.issubdtype(kwargs['dtype'], np.integer), \
            "dtype should be integer"
    else:
        kwargs['dtype'] = np.int16

    traj = opentxt(*args, **kwargs)
    assert len(traj.shape) == 1, "Should be single column file."

    # open limits
    limits = open_limits(limits_file=limits_file, data_length=len(traj))

    # split trajectory
    return np.split(traj, limits)[:-1]


def open_limits(data_length, limits_file=None):
    """
    Load and check limit file.

    The limits give the length of each single trajectory. So e.g.
    [5, 5, 5] for 3 equally-sized subtrajectories of length 5.

    Parameters
    ----------
    data_length : int
        Length of data read.

    limits_file : str, optional
        File name of limit file. Should be single column ascii file.

    """
    if limits_file is None:
        return np.array([data_length])  # for single trajectory
    else:
        # open limits file
        limits = opentxt(limits_file)
        assert len(limits.shape) == 1, "Should be single column file."

        # convert to cumulative sum
        limits = np.cumsum(limits)
        assert data_length == limits[-1], "Limits are inconsistent to data."

        return limits
