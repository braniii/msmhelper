"""
Input and output text files.

BSD 3-Clause License
Copyright (c) 2019, Daniel Nagel
All rights reserved.

Author: Daniel Nagel

TODO:
    - create todo

"""
# ~~~ IMPORT ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import os
import sys
import datetime
import __main__ as main
import getpass  # get username with getpass.getuser()
import platform  # get pc name with platform.node()
import numpy as np
import pandas as pd


# ~~~ RUNTIME INFORMATION ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
USERNAME = getpass.getuser()
PLATFORM = platform.node()
EXEC_DATE = datetime.datetime.now()
try:
    SCRIPT_DIR, SCRIPT_NAME = os.path.split(main.__file__)
except:
    SCRIPT_DIR, SCRIPT_NAME = None, 'console'
else:
    pass


# ~~~ FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def opentxt(file_name, comment='#', usecols=None, nrows=None, skiprows=None):
    """
    Open a text file.

    This method can load an nxm array of floats from an ascii file. It uses
    either pandas read_csv or as fallback the slower numpy laodtxt.

    Parameters
    ----------
    file_name : string
        Name of file to be opened.

    comment : str, optional
        Characters with which a comment starts.

    usecols : int-array, optional
        Columns to be read from the file (zero indexed).

    nrows : int
        The maximum number of lines to be read

    skiprows : int
        The number of leading rows which will be skipped.

    Returns
    -------
    data : ndarray
        Data read from the text file.

    """
    if 'pandas' in sys.modules and len(comment) < 2:
        data = pd.read_csv(file_name,
                           sep=r'\s+',
                           header=None,
                           comment=comment,
                           usecols=usecols,
                           skiprows=skiprows,
                           nrows=nrows).values
        if data.shape[-1] == 1:
            return data.flatten()
        else:
            return data
    elif 'numpy' in sys.modules:
        return np.loadtxt(file_name,
                          comments=comment,
                          usecols=usecols,
                          skiprows=skiprows,
                          max_rows=nrows)
    else:
        print('neither pandas nor numpy was found and pure ' +
              'python pendent is not yet implemented')


def savetxt(file_name,
            data,
            header=None,
            fmt='%.5f'):
    """
    Save nxm array of floats to a text file.

    It uses numpys savetxt method and extends the header with information
    of execution.

    Parameters
    ----------
    file_name : string
        File name to store data.

    data : ndarray
        Data to be stored.

    header : str, optional
        Comment written into the header of the output file.

    fmt : str or sequence of strs, optional
        See numpy.savetxt fmt.

    """
    # prepare header comments
    header_comment = \
        'This file was generated by {} with :\n'.format(SCRIPT_NAME)
    for arg in sys.argv:  # loop over the given arguments
        header_comment += '{} '.format(arg)
    header_comment += '\n\n{}, {}@{}'.format(EXEC_DATE, USERNAME, PLATFORM)
    if header:  # print column title if given
        header_comment += '\n' + header

    # save file
    if 'numpy' in sys.modules:
        np.savetxt(file_name, data, fmt=fmt, header=header_comment)
    else:  # this case should never happen because numpy is required
        print('numpy was not found and pure python pendent is not ' +
              'yet implemented')


def load_limits(limits_file, data_length):
    """
    Load and check limit file.

    Parameters
    ----------
    limits_file : str
        File name of limit file. Should be single column ascii file.

    data_length : int
        Length of data read.

    """
    if not limits_file:
        return [data_length]  # for single trajectory
    else:
        limits = opentxt(limits_file)
        limits = np.cumsum(limits)  # convert to cumulative sum
        # check consitency
        if data_length != limits[-1]:
            print('Length of trajcetory ({}) differs with the stated '
                  'length in the limits file ({}).'
                  .format(data_length, limits[-1]))
            print('break...')
            sys.exit(1)
        return limits
